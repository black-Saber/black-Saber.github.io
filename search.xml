<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[高级Day01---面向对象入门]]></title>
    <url>%2F2017%2F04%2F26%2F%E9%AB%98%E7%BA%A7Day01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[高级Day 01—面向对象入门一、面向对象的概念1.1 什么是面向过程​ 就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。 ​ 生活中的的例子举例。 1.2 什么是面向对象​ 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。 面向对象是一种思维方法 面向对象是一种编程方法 面向对象并不只针对某一种编程语言 1.3 面向对象和面向过程的区别和联系 面向过程过程侧重整个问题的解决步骤，着眼局部或者具体 面向对象侧重具体的功能，让某个对象具有这样的功能。更加侧重于整体。 123456789101112131415161718各自的优缺点面向过程的优点： 流程化使得编程任务明确，在开发之前基本考虑了实现方式和最终结果； 效率高,面向过程强调代码的短小精悍，善于结合数据结构来开发高效率的程序。。 流程明确，具体步骤清楚，便于节点分析。 缺点是：需要深入的思考，耗费精力，代码重用性低，扩展能力差，维护起来难度比较高， 对复杂业务来说，面向过程的模块难度较高，耦合度也比较高。面向对象的优点：结构清晰，程序便于模块化，结构化，抽象化，更加符合人类的思维方式； 封装性，将事务高度抽象，从而便于流程中的行为分析，也便于操作和自省； 容易扩展，代码重用率高，可继承，可覆盖； 实现简单，可有效地减少程序的维护工作量，软件开发效率高。 缺点是：效率低，面向对象在面向过程的基础上高度抽象，从而和代码底层的直接交互非常少机会， 从而不适合底层开发和游戏甚至多媒体开发； 复杂性，对于事务开发而言，事务本身是面向过程的，过度的封装导致事务本身的复杂性提高。 二、编程语言中面向对象的实现方式编程语言对对面向对象的实现主流的有两种方式：基于类的面向对象和基于原型的面向对象。 不管以什么方式实现，都具有面向对象的三大特征： 封装 也就是把客观事物封装成抽象的类或具体的对象，并且类或对象可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 继承 可以让某个类型的对象获得另一个类型的对象的属性的方 多态 不同实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。 2.1基于类的面向对象 典型的语言：Java、C# 对象（object）依靠 类（class)来产生 2.2 基于原型的面向对象 典型的语言：JavaScript 对象（object）则是依靠 构造器（constructor）利用 原型（prototype）构造出来的 三、对JavaScript对象的进一步认识​ ECMA-262 把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。正因为这样（以及其他将要讨论的原因），我们可以把 ECMAScript 的对象想象成散列表：无非就是一组名值对，其中值可以是数据或函数。 1234567891011&lt;script type="text/javascript"&gt; //用大括号括起来的一系列的键值对，就构成了JavaScript对象。这种对象称之为字面量对象。 var person = &#123; name : "张三", // 一个键值对 age : 20, sex : "男", eat : function () &#123; //属性的值是函数，这个时候我们更喜欢把这样的属性称之为方法。 alert("吃东西"); &#125; &#125;&lt;/script&gt; 说明： name : “张三” 一个键值对表示JavaScript对象的一个属性。 name是属性名， “张三” 属性值。 属性可以是任意类型的。可以包括我们以前学的简单数据类型，也可以是函数，也可以是其他的对象。 当一个属性的值是函数的时候，我们更喜欢说这个属性为方法。(如果函数不和对象关联起来的时候，应该叫函数不应该叫方法。只是一种称呼，你完全可以不用理会)。 我们一般说person对象具有了一个方法eat. 将来访问eat的时候，也和调用一个函数一样一样的。 3.1 访问对象的属性 访问一个对象的属性，我们可以直接通过 对象.属性名 和 对象[属性名] 来访问。 1234alert(person.name); // 访问person对象的 name属性值person.age = 30; //修改person对象的 age 属性person.eat(); //既然是调用方法(函数) 则一定还要添加 ()来表示方法的调用alert(person["name"]); // 两种使用方式有一些不同的地方： 对象.属性名的方式，只适合知道了属性的名字，可以直接写。比如： person.age 。如果属性名是个变量，则这种方法无效， 对象.变量名 会出现语法错误。 对象[属性名]，这种方式使用无限制。如果是字符串常量，则应该用””引起来，如果是变量，可以直接使用。 12345person.age = 100; // okvar n = "age";person.a = 101; // no ok 语法错误person["age"] = 102; // okperson[n] = 103; //ok 3.2 给对象添加属性 JavaScript是一种动态语言，可以在代码执行过程中，动态去添加和修改对象的属性。这是与其他面向对象语言一个很大的不同点。 备注：对那些基于类的语言，属性一旦在类中定义完成，对象是不能去动态添加和删除属性的。 12345678//给person对象的属性 girlFriend 赋值。在赋值的过程中，首先会判断这个属性在JavaScript中是否存在，如果存在就对这个//属性重写赋值。如果不存在，就给这个对象添加这个属性，并赋值。person.girlFrient = "小丽"; //给对象添加方法person.play = funcion()&#123; alert("打击high起来");&#125; 3.3 删除对象属性 对JavaScript来说，我们不仅可以动态的添加属性，也可以动态的删除属性。 使用操作符：delete 注意：delete是个操作符，不是方法，所以后面没有必要添加括号啊 123// 使用delete操作关键字，删除person对象的属性agedelete person.age;alert(person.age); //弹出undefined。表示这个属性没有定义 3.4 修改对象属性123456// 把person对象的sex属性的值修改为 女person.sex = "女";person.eat = funcion()&#123; alert("吃货");&#125;person.eat(); //吃货 3.5 使用for…in遍历对象的属性 for…in可以用来遍历对象的所有属性。 1234// 在用for...in遍历的时候， in前面的变量pn指的是属性的名称。for (pn in person) &#123; alert(pn + " " + person[pn]);&#125; 四、多种创建对象的方式 除了上面的使用对象直接量，JavaScript还支持多种方式创建对象 4.1 使用new Object()创建12345678910&lt;script type="text/javascript"&gt; //使用object创建一个对象 完全等同于 var person = &#123;&#125;; var person = new Object(); //给对象添加属性 person.name = "李四"; //给对象添加方法 person.eat = function () &#123; alert("好好吃") &#125;&lt;/script&gt; 4.2 工厂模式创建 虽然 Object 构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。为解决这个问题，人们开始使用工厂模式的一种变体。 工厂模式是软件工程领域一种广为人知的设计模式，这种模式抽象了创建具体对象的过程，考虑到在 ECMAScript 中无法创建类，开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节。 1234567891011121314&lt;script type="text/javascript"&gt; function createPerson(name, age, job) &#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function() &#123; alert(this.name); &#125;; return o; &#125; var person1 = createPerson("张三", 29, "js开发者"); var person2 = createPerson("李四", 27, "java开发者");&lt;/script&gt; createPerson()函数可以多次调用，每调用一次这个函数就会返回一个对象，而且对象的类型仍然是Object类型的。虽然解决了多个相似对象的问题，但却没有解决对象类型识别的问题。 4.3 构造函数模式创建 为了解决对象类型识别问题，又提出了构造函数模式。这种模式，其实在我们创建一些原生对象的时候，比如Array、Object都是调用的他们的构造函数。 看下面的代码 1234567891011121314151617&lt;script type="text/javascript"&gt; function Person (name, age, sex) &#123; this.name = name; this.age = age; this.sex = sex; this.eat = function () &#123; alert(this.name + "在吃东西"); &#125; &#125; var p1 = new Person("张三", 20, "男"); p1.eat(); //张三在在吃东西 var p1 = new Person("李四", 30, "男"); p1.eat(); //李四在在吃东西 alert(p1 instanceof Person); //&lt;/script&gt; 说明： 使用构造函数创建对象，必须使用关键字new ，后面跟着构造函数的名，根据需要传入相应的参数。 其实使用 new 构造函数() 的方式创建对象，经历了下面几个步骤。 创建出来一个新的对象 将构造函数的作用域赋给新对象。意味着这个时候 this就代表了这个新对象。 执行构造函数中的代码。 在本例中就是给新对象添加属性，并给属性初始化值。 构造函数执行完毕之后，默认返回新对象。 所以外面就可以拿到这个刚刚创建的新对象了。 五、构造函数与普通函数的关系 他们都是函数。构造函数也是函数，也可以像普通的函数一样进行调用。 做普通函数调用的时候，因为没有创建新的对象，所以this其实指向了window对象。 12345678910111213function Person()&#123; this.name = "张三"; // 把name属性添加到了window对象上面 alert(this === window); //如果不作为构造方法调用，则 是true&#125;Person(); // 把构造函数当做普通方法调用。这个时候内部的this指向了weindowalert(window.name); //张三function Human()&#123; this.name = "王五"; alert(this instanceof window); // false alert(this instanceof Human); //true&#125;var h = new Human(); //当做构造函数来调用，创建一个对象alert(h.name); 构造函数和普通函数仅仅也仅仅是调用方式的不同。也就是说，随便一个函数你如果用new 的方式去使用，那么他就是一个构造函数。 为了区别，如果一个函数想作为构造函数，作为国际惯例，最好把这个构造函数的首字母大写。]]></content>
      <categories>
        <category>JavaScript知识整理</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HtmlBase]]></title>
    <url>%2F2017%2F04%2F26%2FHtmlBase%2F</url>
    <content type="text"><![CDATA[HTML学习笔记 HTMLHTML 是用来描述网页的一种语言 HTML 指的是超文本标记语言 (Hyper Text Markup Language) HTML 不是一种编程语言，而是一种标记语言 (markup language) 标记语言是一套标记标签 (markup tag) HTML 使用标记标签来描述网页 HTML头部内容 文档（类型）声明 文档类型声明：告知浏览器的解析器用什么文档标准解析这个文档 ：&lt;!doctype html&gt;代表的是 HTML 5 标准，不是标签HTML5 目的： 对文档进行有效性验证。决定浏览器的呈现模式（严格模式是指浏览器按照最高标准来解析文档； 混杂模式则是使用比较宽松的向后兼容的方式显示。） 语言类型声明 en—-&gt;English head标签 head元素是所有头部元素的容器。head内的元素可包含脚本，指示浏览器在何处可以找到样式表，提供元信息，等等。 title标签 定义:浏览器工具栏中的标题 提供页面被添加到收藏夹时显示的标题，显示在搜索引擎结果中的页面标题 meta标签 定义:META标签是HTML语言HEAD区的一个辅助性标签 作用:META标签用来描述一个HTML网页文档的属性，例如作者、日期和时间、网页描述、关键词、页面刷新等。它提供的信息虽然用户不可见，但却是文档的最基本的元数据 元数据： 用来概括描述数据的一些基本数据。也就是描述数据的数据。 http://zq210wl.github.io/2015/01/05/html-meta-tag/ 嵌套： html 父元素 head / body 子元素 父子关系 兄弟关系 父子关系要ctrl+] 兄弟关系要处于同一列 位移快捷键：ctrl + [，ctrl + ] 123456789101112131415161718192021222324252627282930313233343536373839&lt;!-- 文档头（类型）声明 --&gt;&lt;!DOCTYPE html&gt;&lt;!--文档类型是 HTML 5 注意：不是标签 --&gt;&lt;!-- 根元素 --&gt;&lt;html&gt; &lt;!-- 头部 --&gt; &lt;head&gt;&lt;!--head 内部包含的内容绝大部分是不可见的， 主要是用来辅助页面的功能--&gt; &lt;!-- title ： 定义页面的标题 --&gt; &lt;title&gt;标题&lt;/title&gt;&lt;!--meta : 定义页面的元数据 属性 ：charset 针对搜索引擎和解析格式的属性 --&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;!-- 身体 --&gt; &lt;body&gt; &lt;!--body 内部绝大部分都是可见的，主要是用来搭建 HTML 结构 --&gt; &lt;!-- 王 --&gt; &lt;div&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; CSS引入方式 内联样式表 位置： 标签内部 优点： 优先级非常高 缺点： 冗余代码非常多,维护非常困难 使用场景： 针对个别特殊的样式进行修饰 内部样式表 位置： head 标签的内部 优点： 一定程度上实现代码和样式的分离 ,速度快，没有额外的服务器的请求压力 缺点： 造成单个页面体积过大, 代码较乱，前后端沟通困难 使用场景： 大型网站的首页 外部样式表 位置： head 标签的内部 优点： 复用性强，一个样式表可用于多个页面.维护方便，易于改变,代码简洁，易于分工协作 缺点： 容易混淆,会有垃圾代码,会造成服务器请求压力 使用场景： 公共样式的设计,大型网站的二三级页面. 引入方式的优先级问题 内联 &gt; 内部 ？外部 如果优先级相同，谁后加载谁生效——如果优先级不同，谁优先级高的生效 CSS选择器 选择器优先级问题 内联样式表 &gt; ID 选择器 &gt; 类选择器 &gt; 标签名选择器 CSS 选择器（重要） 标签名选择器： 标签名称 + { } 类（class）选择器： . + class 名称 + { } ID 选择器： # + ID名称 + { } 通配符选择器： 用于清除样式；*{一般用于清除样式}不推荐使用，因为通配符需要检索的是全部的标签设置这一个内容，会将所有标签更改，非常影响效率 相邻兄弟选择器： 选择器1+选择器2{css样式} 紧挨着选择器1的选择器2，CSS样式作用在选择器2 同级元素通用选择器： 选择器1~选择器2{css样式} 选择器2必须是选择器1后的同级选择器 属性选择器： [自定义的属性名]{ css样式}[自定义的属性名=属性值]{ css样式} 伪元素选择器： 伪元素选择器实际上并不存在 first-line:为元素中非常常用的一个内容，作用范围：为本内容的首行； 例子：诺只针对p元素生效p::first-line{css样式} first-letter： 作用范围:本内容的首字母； 伪元素选择器前缀就是2个冒号但是浏览器认为选择器只有一个冒号，主要是伪类向后面兼容； 特点： 针对块元素生效 伪类选择器： 动态伪类 hover 当鼠标悬停在某一内容之上触发； link未被访问的链接 visited已被访问过的链接 active 鼠标点击的时候出发，按住时 focus 当获取焦点是触发 如果需要给div获取焦点，可以给div设置tabindex 顺序：hover 需要书写在link visited之后 active 需要书写在hover之后：link visited hover active; 正常伪类 Before 在某一元素之前添加内容 div:before{content:”添加的内容”; after 在某一元素之后添加内容 div:after{content:”添加的内容”;} nth-child选择器 nth-child(2n)选择器匹配父元素中的偶数个子元素，nth-child(2n-1)选择器匹配父元素中的奇数个子元素， nth-last-child（n） 计数从最后一个开始； nth-of-type(n);匹配同类型中的第n个同级兄弟元素； nth-of-type() p:nth-child(2)是父元素标签内的第二个元素，其次这个元素必须是选中的p标签，否则无效 nth-of-type(2)匹配同类型中的第2个同级的兄弟元素； first-child—选择父元素的第一个孩子 last-child—-选择父元素的最后一个孩子 盒子模型 盒模型划分：内容：content ；内边距： padding ；边框： border ；外边距： margin ； 盒模型： 内容**参数** 基础属性：width：height background-color 背景颜色 颜色的写法 英文单词 透明 transparent rgb（red,green,blue） 取值范围 0 - 255 rgba（red,green,blue,alpha） alpha 取值范围 0 ~ 1 .4 -&gt; 0.4 常用的颜色简写: #ffffff -&gt; #fff -&gt; white cccccc -&gt; #ccc -&gt; gray background-image 设置背景图片 url(“ 图片的路径 ”) background-repeat 背景图片的重复方式 repeat 横向纵向全平铺repeat-x横向平铺repeat-y纵向平铺no-repeat 不平铺 background-position 背景图片的定位,值得书写方式： 数值 100px 100px 百分比30%30% 英文单词(常用)top 上 right右bottom下 left左 center 居中 当只设置一个定位方向时另外一个数值默认center background 复合写法: 1.颜色 2.图片路径 3.定位 4.重复方式 ：background:red url(“img/1.png”) bottom no-repeat; background-attachment 设置背景图片是否随着界面滚动而滚动 属性 scroll 滚动 默认值 fixed 固定的 可能造成偏移 background-size 设置背景图片大小 background-size: 600px 300px; 背景尺寸—数值的填写：具体尺寸，百分比，英文—auto 默认尺寸；—cover—等比例的覆盖，直至完全覆盖，背景图片可能超出容器—contain—会将背景图片等 比例缩放，宽度或者高度和父容器相等的时候停止背景图片不会超过父容器 Background-clip ；指定背景的绘制区域，将背景图片适当裁剪 border-box：决定背景图片的剪切范围 border+padding+content padding-box—-padding+content content-box—–content background-origin：决定背景图片的填充的初始位置 border-box—–以border作为起始位置 padding-box—以padding作为起始位置 content-box—-以content作为起始位置 盒模型： 边框参数 border-style：边框常用的样式 solid 实线: 四个方向 top right bottom left dashed（虚线—在大多数浏览器里面为实线）dotted（点线—在大多数浏览器里面为实线） solid （实线）double双实线(如果为1px为实线)none无边框hidden 隐藏（效果与“none”相同–样式冲突时使用隐藏）groove 3D凹槽边框 ridge 垄状边框inset 内陷 outset 外凸 border-width:thinmedium thick 象素（px） border-style: 边框颜色取决于border-color border-color: color边框复合写法 宽度 样式 颜色border:1px dotted blue; 宽度:width border-width: 10px; /上右下左/ border-width: 10px 20px;/上下左右/ border-width: 10px 20px 30px; /上 左右 下/ border-width: 10px 20px 30px 40px; /上 右 下 左/ Border-radius：设置圆角边框 Border-radius:数值1,数值2,数值3,数值4/——————–前四个横向距离:数值5,数值6,数值7,数值8———————后四个纵向距离 数值1,数值2,数值3,数值4———————左上，右上，右下，左下 数值1,数值2,数值3—————————左上，右上左下，右下 数值1,数值2———————————左上右下，右上左下 数值1—————————————左上右上右下左下 盒模型：margin和padding的特性 padding注：两个元素是父子关系，你需调整内容的位置的时候去使用paddiing,可以填充背景图片； 特性: padding 会撑大盒模型 pddding 不能为负数 padding 会显示背景图片 背景时期填充范围 是 整个盒模型的实际范围：———content+padding+border margin注：当两个元素是兄弟关系的时候推荐使用 margin; 特性： margin 不会占我们的盒子空间，他只会影响盒子的位置 margin 不会填充背景图片 margin 可以设置负数 盒模型：盒子阴影 E {box-shadow:inset x-offset y-offset blur-radius spread-radius color} box-shadow:inset 0px 15px 10px -15px #000; 换句说： 对象选择器 {box-shadow:投影方式 X轴偏移量 Y轴偏移量 阴影模糊半径 阴影扩展半径 阴影颜色}著作权归作者所有。 投影方式： 唯一值“inset” X轴偏移量 Y轴偏移量：偏移量可为负 阴影模糊半径：此参数是可选，，但其值只能是为正值，如果其值为0时，表示阴影不具有模糊效果，其值越大阴影的边缘就越模糊； 阴影扩展半径：此参数可选，其值可以是正负值，如果值为正，则整个阴影都延展扩大，反之值为负值是，则缩小 阴影颜色：此参数可选，如果不设定任何颜色时，浏览器会取默认色，但各浏览器默认色不一样，特别是在webkit内核下的safari和chrome浏览器将无色，也就是透明，建议不要省略此参数。 多重阴影 box-shadow:0px 0px 0px 3px #bb0a0a, 0px 0px 0px 6px #2e56bf, 0px 0px 0px 9px #ea982e; 字体阴影： text-shadow:10px 10px 50px black：X轴偏移量 Y轴偏移量 阴影模糊半径 阴影颜色 X轴偏移量 Y轴偏移量：偏移量可为负 阴影模糊半径：此参数是可选，，但其值只能是为正值，如果其值为0时，表示阴影不具有模糊效果，其值越大阴影的边缘就越模糊； 阴影颜色：此参数可选，如果不设定任何颜色时，浏览器会取默认色，但各浏览器默认色不一样，特别是在webkit内核下的safari和chrome浏览器将无色，也就是透明，建议不要省略此参数。 盒模型问题： background-color: red;background: url(“img/1.jpg”) no-repeat;当我设置 background-color 之后，在下面使用 background 的时候background 的背景颜色会失效 background-origin失效问题：background-origin,设置背景图片初始位置；background-position；设置相对于初始位置的偏移量如果背景图片设置了background-attachment:fixed的时候background-origin:就会失效； 问题:边框数值的缺失 ： border-width : 如果缺失，可以显示属性 thin 细的边框 1px, medium 默认值 中等的边框 3px, thick 粗的边框 5px border-style ：如果省略，无法显示 border-color ：如果省略，可以显示 显示的颜色是黑色 利用padding让div居中： 让子元素居中div_1{width:100px;height:100px;background:red;padding：100px;}：父级div_2{width:100px;height:100px;background:yellow;} 子级padding 可以撑大盒子的空间 四个方向 top right bottom left padding 不能为负数！ 问题：当两个元素是兄弟是关系的时候：第一个元素的 margin-bottom 和第二个元素的 margin-top 会产生叠压（两者取最大值） 问题：当两个元素是父子关系的时候,子级元素的第一个元素的margin-top会传递给父级 解决方法： 给父级元素设置 border 给父级元素设置 overflow:hidden; 不要使用margin，而去使用padding注意盒子空间 HTML标签 块元素标签 div：无意义，双标签 主要用于配合界面布局 address： 定义一个地址，双标签，浏览器通常会以斜体的形式显示 h1-h6 ： 一级标题至六级标题 大小依次减小,h1最大，h6最小，h1只允许使用一个，h2使用十个 一下，h3随便用 blockquote： 用于定义一段长的引用文本，引用文本 双标签 会在引用的内容前面自动添加一段距离 cite=”该文本引用的URL” 列表相关内容——ul/li———ol/li—–dl/dt/dd ol： 有序列表，双标签 使用li作为列表项 ol内部属性type 罗马数字： 1：小写英文： a：大写英文： A： 小写希腊字符： i： 大写希腊字符： I 如果需要修改列表的其实数字： ol内部通过start属性修改 在li内部设置属性value修改 ul： 无序列表，双标签 使用li作为列表项 dl 语义：定义列表 dt 语义：定义标题列表项，只能报站文本，图像，超链接表单控件 dd 语义：定义普通列表项，针对dt的解释和说明 设置列表类型 List-style-type: disc黑色实心圆点 Circle黑色空心圆点 square黑色实心正方形 none无 list-style-img:url(“”); 设置列表点的图片类型，需要使用url来引入图片 List-sytle-pisition:inside—–inside：列表修饰处于列表之内——–outside:列表修饰处于列表之外（默认） 复合写法 类型——–位置——-图片：list-style:none inside url(“x.jpg”); ​ 如何清除列表默认样式—–ul,ol{margin:0;padding:0;list-style:none;} 要用转义字符 &lt&gt ​ 块元素特性： 块元素默认独占一行 块元素如果没有设置宽度，默认会继承父级的宽度，会撑满父级的宽度 块元素支持宽高 可以正确显示margin和padding 内联元素标签 span ： 无意义，双，针对一些比较小，需要进行特殊设置的内容去使用 , 因为span,标签可以处以同一行 a： 超链接,属性：href 指定超链接所关联的另一个资源herf 的填写方式 # 特点 污染地址链接 会刷新界面 ### 特点 污染地址链接，不会刷新界面 javascript 特点 不会污染地址连接 不会刷新界面 不会实现跳转 javascript:void(0);简写形式 href=”javascript:;” target 指定使用框架集中的哪一个框架来装载另一个资源 _self 自身 _blank 新窗口 绝对路径：当指定绝对地址的时候，href的值需要填写的URL（统一资源定位器）URL:用于对互联网上的文档或者资源进行寻址的时候使用 相对路径：img/1.png 物理路径：file 锚点&lt;h2 id=&quot;a&quot;&gt;我是标题一&lt;/h2&gt;&lt;a href=&quot;#a&quot;&gt;点击我就会跳到第一段&lt;/a&gt; hr 语义：分割线 br 语义：换行 文本格式化： em 语义：强调的文本 浏览器会以斜体显示 strong 语义：重要的文本 浏览器会以粗体显示 语气强于em 斜体 小写 语义标签 这是短引用! 《HTML,从入门到改行》 How old are you 内联元素特征： 内联元素不会独占一行，多个内联元素会排列在同一行，直到这一行放不下才会换行 内联元素不支持宽高，内联元素的实际宽高由内容撑开 内联元素无法正确显示上下的margin-padding 内联元素的代码进行换行会被解析 内联块元素标签 img 语义:定义图片 单标签 属性,src 指定图片文件所在位置，可以为绝对路径，指定路径, alt 当图片加载失败时，可指定一段文本可作为该图片提示信息。 ​ 可针对SEO进行图片的解释说明 ​ 内联块元素标签特征： 可正常显示宽高； 多个内敛块可以排列在同一行； 代码换行会被解析； 内联元素无法正确显示上下的margin-padding 垂直对齐方式：vertical-align top 顶部 middle 居中 baseline 基线 不用基线都可处理 该问题 bottom 底部 标签之间的相互转换: displayblock 块inline 内联linlie-block 内联块none 无,让标签完全消失，布局的时候不会在考虑该元素 嵌套相关的问题： 块元素内允许嵌套其他元素，p,h1-h6,dt中间不能嵌套其他块元素标签 内联元素一般嵌套内联或内联块 a不能嵌a 问题处理 换行会被解析问题：处理内联块元素img 下方存在间隙 给父级设置line-height为0； 给父级设置 font-size为0； 给图片设置display：block; 给图片设置 垂直对齐方式(非基线) table表格属性 表格 table：双：语义：定义表格 内部： tr 语义：表格中的行 td 语义：表格中的单元格 th 语义：表格中的页眉单元格 caption 语义：表格的标题 属性 cellspacing 设置单元格和单元格之间的距离 cellpadding 设置单元格和内容之间的间距 border： 设置单元格的宽度 ：有默认样式 border-collapse collapse ：合并边框 ：cellspacing 会失效 特殊标签 thead ：表格的头部 表格的页眉部分称之为头部 tbody ：表格的主体 表格的内部的正文称之为主体 tfoot ：表格的页脚 表格底部的统计，计算等行一般称之 ：为表格的页脚 单元格的合并 1.找到单元格合并的起始位置 2.确定单元格合并的方向 横向合并 colspan ：纵向合并 rowspan 3.确定需要合并几个单元格 4.处理理多余的单元格 单元格宽度的计算问题 table-layout auto 宽度根据内容去自动计算 fixed ：固定的 ：需要配合表格的宽度来使用 form表单属性 双 ：语义：定义表单 属性 action：用于记录表单提交的 URL method：用于记录客户端与服务端的交互方式 input：用于向表单内部填写内容 name 内容名称 value 内容数值 type 不填写 默认是文本输入框 text ：文本输入框：style=”outline:none;”取消获取焦点的蓝色边框 maxlength 设置填写内容的最大长度 password ：密码输入框 maxlength 设置填写内容的最大长度 浏览器会以密文的形式来显示内容 radio ：单选框 多个单选框的时候，他们的 name 值需要相同 checked 设置默认选项 拓展 label 可以将点击事件传递给选项 是通过 for 属性来进行传递 用法：需要被传递的标签上，设置 ID 名称 ： checkbox ：复选框 name 不需要相同 checked 设置默认选项 拓展 label 可以将点击事件传递给选项 是通过 for 属性来进行传递 用法：需要被传递的标签上，设置 ID 名称 ： hidden：隐藏 file ：上传文件 button：按钮 submit：提交按钮 reset ：重置按钮 select：定义下拉列表 使用 option 来作为列表项 属性 selected 设置默认的初始值 textarea ：定义文本输入域 通过 CSS 3 的属性 resize：none； 服务器与表单简介 什么叫服务器？ 能够提供服务的机器 服务器又名“伺服器”，是提供计算服 务的设置。服务器需要响应服务请 求，并且还需要承担服务所提供的对 应的保障 什么是表单？ 用于记录发送给服务器的请求内容； 表单在网页中主要负责数据的采集功 能 ；说白了就是获取用户提交的数据并反 馈给后台人员进行验证或者收集的标 签（form） CSS样式 属性 设置文字字号 font-size x-large,xx-large,x-small,xx-small, medium(默认文字大小16px文本如果不进行特殊设置默认16px,font-size是继承的属性 设置文字颜色 color 设置文字的修饰线 text-decoration–underline下划线–overline上划线–line-through删除线–none无—给超链接取消默认样式—————-闪烁线blink 设置文字间距 letter-spacing 设置文字首行缩进 text-indent; px 单位是像素，相对长度单位相对于显示器屏幕分辨率而言 em 也是单位名称也是相对长度单位，相对于当前对象内的文本尺寸而言 rem 相对长度单位 相对于根元素的文本字体尺寸大小 设置文字的大小写转换 text-transform;uppercase 他将全部单词大写 lowercase 他将全部单词小写 capitalize 所有单词首字母大写 设置水平对齐方式 text-align center left right text-align 针对的不是他本身而是针对具有内联元素特征的元素生效 （内联，内敛块） 设置文字行高 line-height 设置文字样式 font-stylenormal 正常 italic 斜体字 oblique 倾斜的文字 italic失效的时候需要使用oblique替代，平时尽量使用italic 设置文字加粗 font-weight normal 正常 bold 加粗 bolder 更粗 设置字体样式 font-family 定义 用于某个元素的字体族的名称或者类族的名称的一个优先表 浏览器会使用他可识别的第一个值,每一个值使用， 分割始终需要提供一个类族名称作为最后选择黑体 SimHei 宋体 SimSun 华文行楷 STKaiti 微软雅黑 Mircosoft YaHei 最后填写一个通用字体 Helvetica 设置文字当中：英文：的显示方式 font-variant normal 普通 small-caps; 英文全部变成大写并且以小字号显示 visibility——规定元素内容是否可见 属性——-hidden会让元素隐藏，会占据空间———-visible元素显示（默认） Overflow规定当内容超出conten时我们如何处理 Auto 超出滚动条显示，当内容超出元素区域的时候会出现滚动条（如果超出才会触发） Scroll超出滚动条显示，当内容超出元素区域的时候会出现滚动条 Hidden超出内容，隐藏 Overflow:使用的时候需要注意两个问题 不同浏览器之间显示时可能存在差异， Overflow兼容性很差，低版本内容可能不支持 Cursor——-用于设置鼠标样式的属性 text—–文本输入–move—移动光标—-pointer——-手掌—–url()—–自定义图片；–推荐图片格式—-.cur—–图片分辨率需要在128*128之内 浮动 浮动——float——–left—right—–none; 特性： 会使元素脱离文档流（布局的时候不会再考虑）； 提升层级半级； 如果没有宽度，浮动元素的内容会去撑开宽度； 浮动元速度会使不支持宽高的元素，支持宽高； 浮动元素对后面与之相邻的下一个元素产生影响 浮动元素什么时候停止呢？ 遇到父级的边框的时候 遇到另一个浮动元素的边框的时候 当一行内容放不下时，该元素会参考上一个元素的高另起一行； 如何清除浮动——————-高度塌陷问题； 给父级设置高度，hight=300px缺点:拓展性太差； 给父级设置浮动—float=left缺点：拓展性太差，本末倒置； 给父级overflow:hidden缺点：超出部分会被隐藏，兼容性差； 给父级display:inline-block缺点再次引发其他问题； 使用clear清除浮动clear—left—right—both—none—–缺点每一次都要确认清除的元素位置（找后一个） 使用:after伪类内部使用需要注意：1content“”；2clear：both3display:block; Float:———-clear—None,left，right——–none,left,right,both; 封装： .clearFIX:after{content:””;clear:both;display:block;}//清除浮动 .clearFIX{zoom:1;/倍率/}//触发IE6的hasLayout 定位 position：static：默认，不定位 relative:相对定位—–top—-left—-right—-bottom ​ 特性： 对定位数值可以设为负数 设置偏移量为正值，则向相反方向移动； 同时设置top&amp;&amp;&amp;bottom—–bottom生效—-left&amp;&amp;right—–right生效 相对定位的位移参考自身原始位置移动； 相对定位不会使元素脱离文档流（布局是还是需要考虑） 相对定位偏移的时候，属性会保留在初始位置，内容会进行偏移； 如果只设置相对定位，而不进行偏移的话，对当前元素本身没有任何影响 absolute:绝对定位-top—-left—-right—-bottom—-z-index; ​ 特性: 绝对定位会使元素脱离文档流； 提升层级一级；会同时压住属性和内容； 会使不支持宽高的元素从新支持宽高； 没有设置宽度的元素，会由内容撑开宽度； 我的绝对定位的位移实际上是参考与离它最近的设置了定位的父级；；（static无效） z-index:专门用于控制层级的属性；——–可以设置为负数—但是假如设为负数，无法响应任何点击事件； fixed：固定定位；top—-left—-right—-bottom—-z-index; ​ 特征: 绝对定位的特性基本一致，区别：位移始终参考与浏览器界面的位置； 固定位置：position:fixed;top:0;left:0; 透明度： opacity—–透明度为：0-1—–描述上是不可继承的，实际测试是可继承的。 替代透明度的方法，可以通过设置rgba()来进行更替； 阐述： position：relative和position:absolute都可以改变元素在文档流中的位置， 同时也会激活top、right，bottom、left。 在未激活之前是可以设置的，但是界面无效果的， z-index未设置之 前，默认是auto网页看起来是二维的结构，但是实际上是存在一个Z轴的，Z轴的大小由z-index来决定。默认情况下，所有的元素都是处于z-index=0这一层的。内部元素去根据元素类 型（block、inline…）长宽，内边距外边距等内容来去排列在z-index=0这一层,但是绝对定位，能够使元素完全脱离文档流，不会在z-index=0这一层保留位置，但是相对定位不会使元素 脱离文档流，布局的时候依旧需要考虑。浮动不会让元素“上浮”到另一层，它实际上还是处于z-index=0这一层，但是它会改变正常的文档流的布局z-index=0这一层，也就是我们俗称的 文档流 定位的兼容性问题： 固定定位在IE6中是不生效的 Position:relative;在IE6,7下，父级的overflow包不住子级的relative——处理方法，父级添加relative; Position:absolute;在IE6下，定位元素的宽和高都是为奇数，在IE6下，定位元素的right和bottom会有1px的偏差；—–无法解决， 在img外部添加一个div限制———–可以避免很多问题！ ​ opacity透明度和transition动画一起连用 ； ICE优先级计算原则 ID class element 继承权重0.001通配符 权重 0.1 标签选择器 权重1 类选择器 权重10 ID选择器 权重100 内联样式表 权重1000 群组选择器与权重没关系 ​ 后代选择器权重相加（子代选择器） ​ 注意：同级选择器的权重现价存在极限，不能越过更高级别的权重。 居中问题 关于页面中一直存在导航居中问题： margin:50%auto; position:absolute;top:50%;left:50%margin-top——自身高度的一半；margin-left——自身宽度的一半; margin:auto;position:absolute;top:0;left:0;right:0;bottom:0;————推荐使用第三种 行高问题—-如何让多行文字居中 父级display:table; 子级：display:table-cell vertical-align:middle;, 水平居中 text-align:center margin-left:auto;margin-right:auto; 垂直居中； 通过上下内边距相同实现 line-height:100px—–height:100px 让一个元素消失 display:none; opacity:0 height:0; vishbility:hidden; position:absolute; top:-9999px position:absolute; zindex:-9999px margin-left:-9999px 文字图片 可以使用字体来代替图片 1.网站下载一个矢量量图 http://www.iconfont.cn/collections/show/748?spm=a313x.7781069.0.0.4UFSmm# 2.将内部字体文件放入当前文件夹下 3.将 CSS 文件中的内容复制当前文件的样式表中 4.删除无关部分 5.设置类的名称，需要和上面的名称相同 外边框 outline 最常使用的情况是绘制在元素周围，为了突出元素的一 条线 常用于清除 input 的默认样式 设置元素是否可拉伸 resize 属性 ： vertical 竖直拉伸 horizontal 横向拉伸 both 竖直和水平都可以进行拉伸 none 不允许进行拉伸 注意 当你的内容需要拉伸的时候，需要配 合 overFlow：hidden； 当这个内容两边的 margin 为 auto 的时候，它的拉伸会同时向两边一起 拉伸 firefox 4.0 + &amp; chrome &amp; safari 中才会生效 无限的优先级 在样式后面添加!importment 怪异盒模型 用于设置 普通盒模型 和 怪异盒模型 的属性 box-sizing 属性 content-box 正常的盒模型 width 指的是内容的宽度 border-box 怪异盒模型 width 指的是 border + padding + width 雪碧图应用原理： 将我们的默认状态图片和滑动状态图片合并成一张图片,background-image，在滑动的时候利用background-position去更改定位位置，我们称这种技术 称为图片翻转技术，演化到最后就是我们的 CSS sprite 命名注意的事项 驼峰命名用于区分不不同的单词 划线 表明从属关系 Es： a. php .fun_dd b. java 驼峰试命名 tabSwhitch c. 混合使用 tabSwitch_ddc d. 结构化命名 （m1-1-1 / m2-1-1 m2-2-1 / m3-1-2 m3-2-1 m3-3-1） 常见的命名 页头：header 如：#header{属性:属性值;} 或.header{属性:属性值;},也许你需要了解class与id 区别及用法 分区：section 登录条：loginBar 标志：logo 侧栏：sideBar 广告：banner 导航：nav 子导航：subNav 菜单：menu 子菜单：subMenu 搜索：search 滚动：scroll 页面主体：main 内容：content 标签页：tab 文章列列表：list 提示信息：msg 小技巧：tips 栏目标题：title 加入：joinus 指南：guild 服务：service 热点：hot 新闻：news 下载：download 注册：regsiter 状态：status 按钮：btn 投票：vote 合作伙伴：partner 友情链接：friendLink 页脚：footer 版权：copyRight 外 套：wrap 版 权：copyRight 商 标：label 标 题：title 顶导航：topnav 边导航：sidebar 左导航：leftsideBar 菜单内容1： menu1Content 右导航：rightsideBar 菜单容量量： menuContainer 标 语：banner 子菜单：submenu 边导航图标：sidebarIcon 注释：note 面包屑：breadCrumb(即页面所处位置导航提示) 容器：container 功能区：shop(如购物⻋车，收银台) 当前：current 页面结构命名 容器： container 页头： header 内容： content / container 页面主题： main 页尾： footer 导航： nav（navigation的缩写） 侧栏： sidebar 栏目： column 页面外围控制整体布局宽度： wrapper 左右中： left / right / center 导航： nav 导航 命名 导航： nav 子导航： subnav 顶导航： topnav 边导航： sidebar 左导航： leftsidebar 右导航： rightsidebar 菜单： menu 子菜单： submenu 标题： title 摘要： summary 功能 命名 标志： logo 广告： banner 登录： login 登录条： loginbar 注册： register 搜索： search 功能区： shop 标题： title 加入： joinus 状态： status 按钮： btn 滚动： scrol l 标签页： tab 文章列列表： list 提示信息： msg（message的缩写） 当前的： current 小技巧： tips 图标： icon 注释： note 指南： guild 服务： service 热点： hot 新闻： news 下载： download 投票： vote 合作伙伴： partner 友情链接： link 版权： copyright CSS样式表以及文件命名 主要的： master.css 模块： module.css 基本公用： base.css 布局、版面： layout.css 主题： themes.css 专栏： columns.css 文字： font.css 表单： forms.css 补丁： mend.css 打印： print.css CSS书写顺序 位置属性 position / top / right / z-index / display / float / … 大小 width / height / padding / margin / … 文字相关 font / line-height / letter-spacing / color / text-align / … 背景 background / border / … 其他 animation / transition / …]]></content>
      <categories>
        <category>HTML知识整理</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
</search>